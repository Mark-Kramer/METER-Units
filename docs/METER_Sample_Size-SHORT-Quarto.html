<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.56">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Sample Size - How much data is enough for your experiment? – BU METER</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/monaco-editor@0.46.0/min/vs/editor/editor.main.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous" referrerpolicy="no-referrer">
  
<style type="text/css">
.monaco-editor pre {
  background-color: unset !important;
}

.qpyodide-editor-toolbar {
  width: 100%;
  display: flex;
  justify-content: space-between;
  box-sizing: border-box;
}

.qpyodide-editor-toolbar-left-buttons, .qpyodide-editor-toolbar-right-buttons {
  display: flex;
}

.qpyodide-non-interactive-loading-container.qpyodide-cell-needs-evaluation, .qpyodide-non-interactive-loading-container.qpyodide-cell-evaluated {
  justify-content: center;
  display: flex;
  background-color: rgba(250, 250, 250, 0.65);
  border: 1px solid rgba(233, 236, 239, 0.65);
  border-radius: 0.5rem;
  margin-top: 15px;
  margin-bottom: 15px;
}

.qpyodide-r-project-logo {
  color: #2767B0; /* R Project's blue color */
}

.qpyodide-icon-status-spinner {
  color: #7894c4;
}

.qpyodide-icon-run-code {
  color: #0d9c29
}

.qpyodide-output-code-stdout {
  color: #111;
}

.qpyodide-output-code-stderr {
  color: #db4133;
}

.qpyodide-editor {
  border: 1px solid #EEEEEE;
}

.qpyodide-editor-toolbar {
  background-color: #EEEEEE;
  padding: 0.2rem 0.5rem;
}

.qpyodide-button {
  background-color: #EEEEEE;
  display: inline-block;
  font-weight: 400;
  line-height: 1;
  text-decoration: none;
  text-align: center;
  color: #000;
  border-color: #dee2e6;
  border: 1px solid rgba(0,0,0,0);
  padding: 0.375rem 0.75rem;
  font-size: .9rem;
  border-radius: 0.25rem;
  transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;
}

.qpyodide-button:hover {
  color: #000;
  background-color: #d9dce0;
  border-color: #c8ccd0;
}

.qpyodide-button:disabled,.qpyodide-button.disabled,fieldset:disabled .qpyodide-button {
  pointer-events: none;
  opacity: .65
}

.qpyodide-button-reset {
  color: #696969; /*#4682b4;*/
}

.qpyodide-button-copy {
  color: #696969;
}


/* Custom styling for RevealJS Presentations*/

/* Reset the style of the interactive area */
.reveal div.qpyodide-interactive-area {
  display: block;
  box-shadow: none;
  max-width: 100%;
  max-height: 100%;
  margin: 0;
  padding: 0;
} 

/* Provide space to entries */
.reveal div.qpyodide-output-code-area pre div {
  margin: 1px 2px 1px 10px;
}

/* Collapse the inside code tags to avoid extra space between line outputs */
.reveal pre div code.qpyodide-output-code-stdout, .reveal pre div code.qpyodide-output-code-stderr {
  padding: 0;
  display: contents;
}

.reveal pre div code.qpyodide-output-code-stdout {
  color: #111;
}

.reveal pre div code.qpyodide-output-code-stderr {
  color: #db4133;
}


/* Create a border around console and output (does not effect graphs) */
.reveal div.qpyodide-console-area {
  border: 1px solid #EEEEEE;
  box-shadow: 2px 2px 10px #EEEEEE;
}

/* Cap output height and allow text to scroll */
/* TODO: Is there a better way to fit contents/max it parallel to the monaco editor size? */
.reveal div.qpyodide-output-code-area pre {
  max-height: 400px;
  overflow: scroll;
}
</style>
<script type="module">
// Document level settings ----

// Determine if we need to install python packages
globalThis.qpyodideInstallPythonPackagesList = [''];

// Check to see if we have an empty array, if we do set to skip the installation.
globalThis.qpyodideSetupPythonPackages = !(qpyodideInstallPythonPackagesList.indexOf("") !== -1);

// Display a startup message?
globalThis.qpyodideShowStartupMessage = true;

// Describe the webR settings that should be used
globalThis.qpyodideCustomizedPyodideOptions = {
  "indexURL": "https://cdn.jsdelivr.net/pyodide/v0.26.1/full/",
  "env": {
    "HOME": "/home/pyodide",
  }, 
  stdout: (text) => {qpyodideAddToOutputArray(text, "out");},
  stderr: (text) => {qpyodideAddToOutputArray(text, "error");}
}

// Store cell data
globalThis.qpyodideCellDetails = [{"id":1,"code":"N = 100","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":2,"code":"# Load modules\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import pearsonr\nimport statsmodels.api as sm\n# Load custom functions\nimport requests\nurl = \"https://raw.githubusercontent.com/Mark-Kramer/METER-Units/main/sample_size_functions.py\"\nresponse = requests.get(url)\nexec(response.text)\n\nx,lifespan = load_data(N)             # ... and load the data with this many N.","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":3,"code":"plt.figure()\nplt.scatter(x,lifespan)\nplt.xlabel('Genetic biomarker x')\nplt.ylabel('Lifespan (years)')\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":4,"code":"# Estimate a line from the data.\nfrom statsmodels.formula.api import ols\ndat                = {\"x\": x, \"lifespan\": lifespan}\nregression_results = ols(\"lifespan ~ 1 + x\", data=dat).fit()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":5,"code":"slope_estimate = regression_results.params.iloc[1]\nprint('Slope estimate                   = {:.3f}'.format(slope_estimate)\nprint('Standard error of slope estimate = {:.3f}'.format(regression_results.bse['x']))\nprint('p-value                          = {:.3f}'.format(regression_results.pvalues.iloc[1]))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":6,"code":"pred   = regression_results.get_prediction().summary_frame()\nmn     = pred['mean']\nci_low = pred['mean_ci_lower'] \nci_upp = pred['mean_ci_upper']\n\n# And plot it.\nindices_sorted = np.argsort(x,0)\nplt.figure()\nplt.scatter(x,lifespan)\nplt.plot(x[indices_sorted],mn[indices_sorted], 'r')\nplt.plot(x[indices_sorted],ci_low[indices_sorted], ':r')\nplt.plot(x[indices_sorted],ci_upp[indices_sorted], ':r')\nplt.xlabel('Genetic biomarker x')\nplt.ylabel('Lifespan (years)')\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":7,"code":"N_resampled = N;","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":8,"code":"ind = np.random.choice(np.size(x), N_resampled)\nprint(ind)","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":9,"code":"x_resampled        = x[ind]\nlifespan_resampled = lifespan[ind]","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":10,"code":"plt.figure()\nplt.scatter(x, lifespan, color='orange', alpha=0.25, label='Original Data')\nplt.scatter(x_resampled, lifespan_resampled, color='blue', alpha=0.25, label='Resampled Data')\nplt.xlabel('Genetic biomarker x')\nplt.ylabel('Lifespan (years)');\nplt.legend()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":11,"code":"# Estimate a line from the resampled data.\nfrom statsmodels.formula.api import ols\ndat_resampled                = {\"x\": x_resampled, \"lifespan\": lifespan_resampled}\nregression_results_resampled = ols(\"lifespan ~ 1 + x\", data=dat_resampled).fit()\n\nprint('Slope estimate (resampled data)                   = {:.3f}'.format(regression_results_resampled.params.iloc[1]))\nprint('Standard error of slope estimate (resampled data) = {:.3f}'.format(regression_results_resampled.bse['x']))\nprint('p-value (resampled data)                          = {:.3f}'.format(regression_results_resampled.pvalues.iloc[1]))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":12,"code":"N_resampled = N\nK = 1000\np_values = np.zeros(K)\nfor k in np.arange(K):                                 # For each k,\n    ind = np.random.choice(np.size(x), N_resampled)    # ... get N_resampled indices,\n    x_resampled = x[ind]                               # ... to create the pseudodata.\n    lifespan_resampled = lifespan[ind]                 # Estimate the line,\n    dat                = {\"x\": x_resampled, \"lifespan\": lifespan_resampled}\n    regression_results = ols(\"lifespan ~ 1 + x\", data=dat).fit()\n    p_values[k] = regression_results.pvalues.iloc[1]         # ... and save the p-value of the slope.","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":13,"code":"plt.figure()\nplt.hist(p_values, bins=np.arange(0,1,0.05));\nplt.xlabel('p-values')\nplt.ylabel('Counts')\nplt.grid()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":14,"code":"alpha = 0.05;\nstatistical_power = np.sum(p_values < 0.05)/K\nprint(statistical_power)","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":15,"code":"plt.figure()\nplt.hist(p_values, bins=np.arange(0,1,0.025));\nplt.xlabel('p-values')\nplt.ylabel('Counts')\nplt.grid()\nplt.axvline(x=0.05, color='red', label='alpha')\nplt.legend()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":16,"code":"N_resampled = N\nalpha       = 0.05\nK           = 1000\np_values = np.zeros(K)\nfor k in np.arange(K):                                 # For each k,\n    ind = np.random.choice(np.size(x), N_resampled)    # ... get N_resampled indices,\n    x_resampled = x[ind]                               # ... to create the pseudodata.\n    lifespan_resampled = lifespan[ind]                 # Estimate the line,\n    dat                = {\"x\": x_resampled, \"lifespan\": lifespan_resampled}\n    regression_results = ols(\"lifespan ~ 1 + x\", data=dat).fit()\n    p_values[k] = regression_results.pvalues.iloc[1]         # ... and save the p-value of the slope.\nstatistical_power = np.sum(p_values < 0.05)/K\nprint('Statistical power = {:.3f}'.format(statistical_power), 'for N_resampled={:.0f}'.format(N_resampled), 'and alpha={:.2f}'.format(alpha))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":17,"code":"plt.figure()\nplt.hist(x)\nplt.xlabel('Biomarker x')\nplt.ylabel('Number of observations')\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":18,"code":"# Estimating the parameters of the normal distribution for the biomarker x\nmean_x = np.mean(x)\nstd_x  = np.std(x)\nprint('Mean of x               = {:.2f}'.format(mean_x))\nprint('Standard deviation of x = {:.2f}'.format(std_x))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":19,"code":"N_modeled = 100;\nx_modeled = np.random.normal(loc=mean_x, scale=std_x, size=[N_modeled,1])\nprint(x_modeled)","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":20,"code":"plt.figure()\nplt.hist(x,         bins=30, alpha=0.5, label='Original Data (x)', color='blue')\nplt.hist(x_modeled, bins=30, alpha=0.5, label='Modeled data (x_modeled)', color='red')\nplt.title('Histogram of Original Data and Samples')\nplt.xlabel('Value')\nplt.ylabel('Frequency')\nplt.legend()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":21,"code":"# Estimate a line from the data.\nfrom statsmodels.formula.api import ols\ndat   = {\"x\": x, \"lifespan\": lifespan}\nmodel = ols(\"lifespan ~ 1 + x\", data=dat).fit()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":22,"code":"slope     = model.params.iloc[1]\nintercept = model.params.iloc[0]\n\nprint('Slope estimate     = {:.2f}'.format(slope))\nprint('Intercept estimate = {:.2f}'.format(intercept))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":23,"code":"# Get the model prediciton.\npred   = model.get_prediction().summary_frame();  mn = pred['mean']\n# And plot it.\nindices_sorted = np.argsort(x,0)\nplt.figure()\nplt.scatter(x,lifespan)\nplt.plot(x[indices_sorted[:,0]],mn[indices_sorted[:,0]], 'r')\nplt.xlabel('Genetic biomarker x')\nplt.ylabel('Lifespan (years)')\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":24,"code":"dispersion = np.sqrt(model.scale)\nprint('Dispersion parameter = {:.2f}'.format(dispersion))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":25,"code":"N_modeled = N\nx_modeled        = np.random.normal(loc=mean_x, scale=std_x, size=[N_modeled,1])\nlifespan_modeled = intercept + slope * x_modeled + np.random.normal(loc=0.0, scale=dispersion, size=[N_modeled,1])","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":26,"code":"plt.figure()\nplt.scatter(x, lifespan, color='orange', alpha=0.25, label='Original Data')\nplt.scatter(x_modeled, lifespan_modeled, color='blue', alpha=0.25, label='Modeled Data')\nplt.xlabel('Genetic biomarker x')\nplt.ylabel('Lifespan (years)')\nplt.legend()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":27,"code":"# Estimate a line from the modeled data.\nfrom statsmodels.formula.api import ols\ndat_modeled                = {\"x\": x_modeled, \"lifespan\": lifespan_modeled}\nregression_results_modeled = ols(\"lifespan ~ 1 + x\", data=dat_modeled).fit()\n\nprint('Slope estimate (modeled data)                   = {:.3f}'.format(regression_results_modeled.params.iloc[1]))\nprint('Standard error of slope estimate (modeled data) = {:.3f}'.format(regression_results_modeled.bse['x']))\nprint('p-value (modeled data)                          = {:.3f}'.format(regression_results_modeled.pvalues.iloc[1]))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":28,"code":"N_modeled = N\nK = 1000\np_values = np.zeros(K)\nfor k in np.arange(K):                                 # For each k,\n    x_modeled          = np.random.normal(loc=mean_x, scale=std_x, size=[N_modeled,1])  # Simulate the model of biomarker x\n    lifespan_modeled   = intercept + slope * x_modeled + np.random.normal(loc=0.0, scale=dispersion, size=[N_modeled,1]) # Simulate the model of lifespan\n    dat                = {\"x\": x_modeled, \"lifespan\": lifespan_modeled}\n    regression_results = ols(\"lifespan ~ 1 + x\", data=dat).fit()\n    p_values[k] = regression_results.pvalues.iloc[1]         # ... and save the p-value of the slope.","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":29,"code":"plt.figure()\nplt.hist(p_values, bins=np.arange(0,1.05,0.05));\nplt.xlabel('p-values')\nplt.ylabel('Counts')\nplt.grid()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":30,"code":"alpha = 0.05;\nstatistical_power = np.sum(p_values < 0.05)/K\nprint(statistical_power)","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":31,"code":"plt.figure()\nplt.hist(p_values, bins=np.arange(0,1,0.025));\nplt.xlabel('p-values')\nplt.ylabel('Counts')\nplt.grid()\nplt.axvline(x=0.05, color='red', label='alpha')\nplt.legend()\nplt.show()","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":32,"code":"N_modeled = 1000\nalpha     = 0.05\nK         = 1000\np_values  = np.zeros(K)\nfor k in np.arange(K):                                 # For each k,\n    x_modeled          = np.random.normal(loc=mean_x, scale=std_x, size=[N_modeled,1])  # Simulate the model of biomarker x\n    lifespan_modeled   = intercept + slope * x_modeled + np.random.normal(loc=0.0, scale=dispersion, size=[N_modeled,1]) # Simulate the model of lifespan\n    dat                = {\"x\": x_modeled, \"lifespan\": lifespan_modeled}\n    regression_results = ols(\"lifespan ~ 1 + x\", data=dat).fit()\n    p_values[k] = regression_results.pvalues.iloc[1]         # ... and save the p-value of the slope.\nstatistical_power = np.sum(p_values < 0.05)/K\nprint('Statistical power = {:.3f}'.format(statistical_power), 'for N_modeled={:.0f}'.format(N_modeled), 'and alpha={:.2f}'.format(alpha))","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}},{"id":33,"code":"# Load modules\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import pearsonr\nimport statsmodels.api as sm\n# Load custom functions\nimport requests\nurl = \"https://raw.githubusercontent.com/Mark-Kramer/METER-Units/main/sample_size_functions.py\"\nresponse = requests.get(url)\nexec(response.text)\n\nN = 100\ndo_nothing_function(N)","options":{"output":"true","context":"interactive","comment":"","label":"","results":"markup","fig-height":5,"read-only":"false","autorun":"","classes":"","fig-cap":"","fig-width":7,"warning":"true","dpi":72,"out-width":"700px","message":"true","out-height":""}}];


</script>
<script type="module">
// Declare startupMessageqpyodide globally
globalThis.qpyodideStartupMessage = document.createElement("p");

// Function to set the button text
globalThis.qpyodideSetInteractiveButtonState = function(buttonText, enableCodeButton = true) {
  document.querySelectorAll(".qpyodide-button-run").forEach((btn) => {
    btn.innerHTML = buttonText;
    btn.disabled = !enableCodeButton;
  });
}

// Function to update the status message in non-interactive cells
globalThis.qpyodideUpdateStatusMessage = function(message) {
  document.querySelectorAll(".qpyodide-status-text.qpyodide-cell-needs-evaluation").forEach((elem) => {
    elem.innerText = message;
  });
}

// Function to update the status message
globalThis.qpyodideUpdateStatusHeader = function(message) {

  if (!qpyodideShowStartupMessage) return;

  qpyodideStartupMessage.innerHTML = message;
}

// Status header update with customized spinner message
globalThis.qpyodideUpdateStatusHeaderSpinner = function(message) {

  qpyodideUpdateStatusHeader(`
    <i class="fa-solid fa-spinner fa-spin qpyodide-icon-status-spinner"></i>
    <span>${message}</span>
  `);
}


// Function that attaches the document status message
function qpyodideDisplayStartupMessage(showStartupMessage) {
  if (!showStartupMessage) {
    return;
  }

  // Get references to header elements
  const headerHTML = document.getElementById("title-block-header");
  const headerRevealJS = document.getElementById("title-slide");

  // Create the outermost div element for metadata
  const quartoTitleMeta = document.createElement("div");
  quartoTitleMeta.classList.add("quarto-title-meta");

  // Create the first inner div element
  const firstInnerDiv = document.createElement("div");
  firstInnerDiv.setAttribute("id", "qpyodide-status-message-area");

  // Create the second inner div element for "Pyodide Status" heading and contents
  const secondInnerDiv = document.createElement("div");
  secondInnerDiv.setAttribute("id", "qpyodide-status-message-title");
  secondInnerDiv.classList.add("quarto-title-meta-heading");
  secondInnerDiv.innerText = "Pyodide Status";

  // Create another inner div for contents
  const secondInnerDivContents = document.createElement("div");
  secondInnerDivContents.setAttribute("id", "qpyodide-status-message-body");
  secondInnerDivContents.classList.add("quarto-title-meta-contents");

  // Describe the Pyodide state
  qpyodideStartupMessage.innerText = "🟡 Loading...";
  qpyodideStartupMessage.setAttribute("id", "qpyodide-status-message-text");
  // Add `aria-live` to auto-announce the startup status to screen readers
  qpyodideStartupMessage.setAttribute("aria-live", "assertive");

  // Append the startup message to the contents
  secondInnerDivContents.appendChild(qpyodideStartupMessage);

  // Combine the inner divs and contents
  firstInnerDiv.appendChild(secondInnerDiv);
  firstInnerDiv.appendChild(secondInnerDivContents);
  quartoTitleMeta.appendChild(firstInnerDiv);

  // Determine where to insert the quartoTitleMeta element
  if (headerHTML || headerRevealJS) {
    // Append to the existing "title-block-header" element or "title-slide" div
    (headerHTML || headerRevealJS).appendChild(quartoTitleMeta);
  } else {
    // If neither headerHTML nor headerRevealJS is found, insert after "Pyodide-monaco-editor-init" script
    const monacoScript = document.getElementById("qpyodide-monaco-editor-init");
    const header = document.createElement("header");
    header.setAttribute("id", "title-block-header");
    header.appendChild(quartoTitleMeta);
    monacoScript.after(header);
  }
}

qpyodideDisplayStartupMessage(qpyodideShowStartupMessage);
</script>
<script type="module">
// Create a logging setup
globalThis.qpyodideMessageArray = []

// Add messages to array
globalThis.qpyodideAddToOutputArray = function(message, type) {
  qpyodideMessageArray.push({ message, type });
}

// Function to reset the output array
globalThis.qpyodideResetOutputArray = function() {
  qpyodideMessageArray = [];
}

globalThis.qpyodideRetrieveOutput = function() {
  return qpyodideMessageArray.map(entry => entry.message).join('\n');
}

// Start a timer
const initializePyodideTimerStart = performance.now();

// Encase with a dynamic import statement
globalThis.qpyodideInstance = await import(
  qpyodideCustomizedPyodideOptions.indexURL + "pyodide.mjs").then(
   async({ loadPyodide }) => {

    console.log("Start loading Pyodide");
    
    // Populate Pyodide options with defaults or new values based on `pyodide`` meta
    let mainPyodide = await loadPyodide(
      qpyodideCustomizedPyodideOptions
    );
    
    // Setup a namespace for global scoping
    // await loadedPyodide.runPythonAsync("globalScope = {}"); 
    
    // Update status to reflect the next stage of the procedure
    qpyodideUpdateStatusHeaderSpinner("Initializing Python Packages");

    // Load the `micropip` package to allow installation of packages.
    await mainPyodide.loadPackage("micropip");
    await mainPyodide.runPythonAsync(`import micropip`);

    // Load the `pyodide_http` package to shim uses of `requests` and `urllib3`.
    // This allows for `pd.read_csv(url)` to work flawlessly.
    // Details: https://github.com/coatless-quarto/pyodide/issues/9
    await mainPyodide.loadPackage("pyodide_http");
    await mainPyodide.runPythonAsync(`
    import pyodide_http
    pyodide_http.patch_all()  # Patch all libraries
    `);

    // Load the `matplotlib` package with necessary environment hook
    await mainPyodide.loadPackage("matplotlib");

    // Set the backend for matplotlib to be interactive.
    await mainPyodide.runPythonAsync(`
    import matplotlib
    matplotlib.use("module://matplotlib_pyodide.html5_canvas_backend")
    from matplotlib import pyplot as plt
    `);

    // Unlock interactive buttons
    qpyodideSetInteractiveButtonState(
      `<i class="fa-solid fa-play qpyodide-icon-run-code"></i> <span>Run Code</span>`, 
      true
    );

    // Set document status to viable
    qpyodideUpdateStatusHeader(
      "🟢 Ready!"
    );

    // Assign Pyodide into the global environment
    globalThis.mainPyodide = mainPyodide;

    console.log("Completed loading Pyodide");
    return mainPyodide;
  }
);

// Stop timer
const initializePyodideTimerEnd = performance.now();

// Create a function to retrieve the promise object.
globalThis._qpyodideGetInstance = function() {
    return qpyodideInstance;
}

</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">BU METER</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./METER_Sample_Size-SHORT-Quarto.html" aria-current="page"> 
<span class="menu-text">Sample Size</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#just-google-it" id="toc-just-google-it" class="nav-link active" data-scroll-target="#just-google-it">1 - Just Google it?</a></li>
  <li><a href="#underpowered-experiments-are-doomed-to-failure." id="toc-underpowered-experiments-are-doomed-to-failure." class="nav-link" data-scroll-target="#underpowered-experiments-are-doomed-to-failure.">2- Underpowered experiments are doomed to failure.</a>
  <ul class="collapse">
  <li><a href="#slope-estimate" id="toc-slope-estimate" class="nav-link" data-scroll-target="#slope-estimate">Slope estimate</a></li>
  <li><a href="#standard-error-of-slope-estimate" id="toc-standard-error-of-slope-estimate" class="nav-link" data-scroll-target="#standard-error-of-slope-estimate">Standard error of slope estimate</a></li>
  <li><a href="#p-value" id="toc-p-value" class="nav-link" data-scroll-target="#p-value">p-value</a></li>
  </ul></li>
  <li><a href="#choose-your-own-adventure" id="toc-choose-your-own-adventure" class="nav-link" data-scroll-target="#choose-your-own-adventure">Choose your own adventure …</a>
  <ul class="collapse">
  <li><a href="#which-path-will-you-pursue-to-compute-the-sample-size" id="toc-which-path-will-you-pursue-to-compute-the-sample-size" class="nav-link" data-scroll-target="#which-path-will-you-pursue-to-compute-the-sample-size">Which path will you pursue to compute the sample size?</a></li>
  <li><a href="#a--ill-resample-turn-to-page-3a." id="toc-a--ill-resample-turn-to-page-3a." class="nav-link" data-scroll-target="#a--ill-resample-turn-to-page-3a."><strong>3A-</strong> I’ll resample: Turn To Page 3A.</a></li>
  <li><a href="#b--ill-build-models-turn-to-page-3b." id="toc-b--ill-build-models-turn-to-page-3b." class="nav-link" data-scroll-target="#b--ill-build-models-turn-to-page-3b."><strong>3B-</strong> I’ll build models Turn To Page 3B.</a></li>
  <li><a href="#c--ill-use-my-current-sample-size-choice-turn-to-page-3c." id="toc-c--ill-use-my-current-sample-size-choice-turn-to-page-3c." class="nav-link" data-scroll-target="#c--ill-use-my-current-sample-size-choice-turn-to-page-3c."><strong>3C-</strong> I’ll use my current sample size choice Turn to Page 3C.</a></li>
  </ul></li>
  <li><a href="#3A" id="toc-3A" class="nav-link" data-scroll-target="#3A">3A- With resampling you can compute the sample size!</a>
  <ul class="collapse">
  <li><a href="#resampling-procedure-introduction" id="toc-resampling-procedure-introduction" class="nav-link" data-scroll-target="#resampling-procedure-introduction">Resampling procedure (Introduction)</a></li>
  <li><a href="#resampling-procedure-4-steps" id="toc-resampling-procedure-4-steps" class="nav-link" data-scroll-target="#resampling-procedure-4-steps">Resampling procedure (4 steps)</a></li>
  <li><a href="#resampling-procedure-step-1" id="toc-resampling-procedure-step-1" class="nav-link" data-scroll-target="#resampling-procedure-step-1">Resampling procedure: Step 1</a></li>
  <li><a href="#resampling-procedure-step-2" id="toc-resampling-procedure-step-2" class="nav-link" data-scroll-target="#resampling-procedure-step-2">Resampling procedure: Step 2</a></li>
  <li><a href="#resampling-procedure-step-3" id="toc-resampling-procedure-step-3" class="nav-link" data-scroll-target="#resampling-procedure-step-3">Resampling procedure: Step 3</a></li>
  <li><a href="#resampling-procedure-step-4" id="toc-resampling-procedure-step-4" class="nav-link" data-scroll-target="#resampling-procedure-step-4">Resampling procedure: Step 4</a></li>
  <li><a href="#putting-it-all-together" id="toc-putting-it-all-together" class="nav-link" data-scroll-target="#putting-it-all-together">Putting it all together</a></li>
  <li><a href="#resampling-procedure-to-estimate-the-statistical-power-6-steps" id="toc-resampling-procedure-to-estimate-the-statistical-power-6-steps" class="nav-link" data-scroll-target="#resampling-procedure-to-estimate-the-statistical-power-6-steps">Resampling procedure to estimate the statistical power (6 steps)</a></li>
  <li><a href="#resampling-procedure-steps-1-4" id="toc-resampling-procedure-steps-1-4" class="nav-link" data-scroll-target="#resampling-procedure-steps-1-4">Resampling procedure: Steps 1-4</a></li>
  <li><a href="#resampling-procedure-step-5" id="toc-resampling-procedure-step-5" class="nav-link" data-scroll-target="#resampling-procedure-step-5">Resampling procedure: Step 5</a></li>
  <li><a href="#resampling-procedure-step-6" id="toc-resampling-procedure-step-6" class="nav-link" data-scroll-target="#resampling-procedure-step-6">Resampling procedure: Step 6</a></li>
  <li><a href="#turn-to-page-4-summary" id="toc-turn-to-page-4-summary" class="nav-link" data-scroll-target="#turn-to-page-4-summary">Turn to Page 4 Summary</a></li>
  </ul></li>
  <li><a href="#3B" id="toc-3B" class="nav-link" data-scroll-target="#3B">3B- Build models to compute the sample size!</a>
  <ul class="collapse">
  <li><a href="#modeling-procedure-introduction" id="toc-modeling-procedure-introduction" class="nav-link" data-scroll-target="#modeling-procedure-introduction">Modeling procedure (Introduction)</a></li>
  <li><a href="#modeling-procedure-4-steps" id="toc-modeling-procedure-4-steps" class="nav-link" data-scroll-target="#modeling-procedure-4-steps">Modeling procedure (4 steps)</a></li>
  <li><a href="#modeling-procedure-step-1" id="toc-modeling-procedure-step-1" class="nav-link" data-scroll-target="#modeling-procedure-step-1">Modeling procedure: Step 1</a></li>
  <li><a href="#modeling-procedure-step-2" id="toc-modeling-procedure-step-2" class="nav-link" data-scroll-target="#modeling-procedure-step-2">Modeling procedure: Step 2</a></li>
  <li><a href="#modeling-procedure-step-3" id="toc-modeling-procedure-step-3" class="nav-link" data-scroll-target="#modeling-procedure-step-3">Modeling procedure: Step 3</a></li>
  <li><a href="#modeling-procedure-step-4" id="toc-modeling-procedure-step-4" class="nav-link" data-scroll-target="#modeling-procedure-step-4">Modeling procedure: Step 4</a></li>
  <li><a href="#now-lets-use-this-modeling-approach-to-determine-a-good-sample-size-for-our-experiment." id="toc-now-lets-use-this-modeling-approach-to-determine-a-good-sample-size-for-our-experiment." class="nav-link" data-scroll-target="#now-lets-use-this-modeling-approach-to-determine-a-good-sample-size-for-our-experiment.">Now, let’s use this modeling approach to determine a good sample size for our experiment.</a></li>
  <li><a href="#modeling-procedure-to-estimate-the-statistical-power-6-steps" id="toc-modeling-procedure-to-estimate-the-statistical-power-6-steps" class="nav-link" data-scroll-target="#modeling-procedure-to-estimate-the-statistical-power-6-steps">Modeling procedure to estimate the statistical power (6 steps)</a></li>
  <li><a href="#modeling-procedure-steps-1-4" id="toc-modeling-procedure-steps-1-4" class="nav-link" data-scroll-target="#modeling-procedure-steps-1-4">Modeling procedure: Steps 1-4</a></li>
  <li><a href="#modeling-procedure-step-5" id="toc-modeling-procedure-step-5" class="nav-link" data-scroll-target="#modeling-procedure-step-5">Modeling procedure: Step 5</a></li>
  <li><a href="#modeling-procedure-step-6" id="toc-modeling-procedure-step-6" class="nav-link" data-scroll-target="#modeling-procedure-step-6">Modeling procedure: Step 6</a></li>
  <li><a href="#turn-to-page-4-summary." id="toc-turn-to-page-4-summary." class="nav-link" data-scroll-target="#turn-to-page-4-summary.">Turn to Page 4 Summary.</a></li>
  </ul></li>
  <li><a href="#3C" id="toc-3C" class="nav-link" data-scroll-target="#3C">3C- Do nothing, I’m happy with the current sample size choice</a></li>
  <li><a href="#Summary" id="toc-Summary" class="nav-link" data-scroll-target="#Summary">4- Summary</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">
<script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.46.0/min/vs/loader.js"></script>
<script type="module" id="qpyodide-monaco-editor-init">

  // Configure the Monaco Editor's loader
  require.config({
    paths: {
      'vs': 'https://cdn.jsdelivr.net/npm/monaco-editor@0.46.0/min/vs'
    }
  });
</script>

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Sample Size - How much data is enough for your experiment?</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="just-google-it" class="level1">
<h1>1 - Just Google it?</h1>
<p>Based on the groundbreaking research previously conducted in your lab, you and your collaborators have formulated a compelling scientific hypothesis: substance <span class="math inline">\(x\)</span> could be a genetic biomarker for longevity, potentially influencing the age at which individuals pass away. This intriguing hypothesis opens up a new frontier in our understanding of genetics and lifespan, promising significant advancements in the field.</p>
<p>Before we can embark on an experimental journey to test the predictive power of this novel biomarker, we must first tackle a critical step: determining the appropriate sample size for a follow-up research study. The sample size is not just a number; it is a cornerstone of experimental design that ensures our data will be robust enough to support or refute our hypothesis.</p>
<p>To accurately compute this sample size, we need to consider our prior beliefs and existing knowledge about substance <span class="math inline">\(x\)</span> and its relationship to longevity. Let’s delve into the specifics. Imagine we have the following limited yet crucial pieces of information:</p>
<ol type="1">
<li><p><strong>Distribution of Substance <span class="math inline">\(x\)</span>:</strong> The expression levels of substance <span class="math inline">\(x\)</span> in people follow a normal distribution.</p></li>
<li><p><strong>Impact on Longevity:</strong> Individuals at the high end of the expression spectrum tend to live approximately 5 years longer than those at the low end.</p></li>
</ol>
<p>Given these insights, our task is to calculate a sample size that can yield statistically significant results. This endeavor will not only help us test our hypothesis with precision but also pave the way for future research that could revolutionize our understanding of genetic influences on lifespan. Let’s proceed with this vital calculation, knowing that the outcomes will bring us one step closer to potentially groundbreaking discoveries in genetic biomarkers and longevity.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Given this information, how many individuals should we include in our study to have a reasonable chance of demonstrating this hypothesis is correct? (I.e., What is the <strong>sample size</strong>?)
</div>
</div>
<div class="callout-body-container callout-body">

</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<b>Wait, I have no idea how to answer this?</b>
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Don’t worry!</li>
<li>The goal of this unit is to teach you to tackle this problem.</li>
<li>Let’s first come up with <strong>any approach</strong> to compute a sample size, even if we’re not confident in the results.</li>
</ul>
<p>A few possible places to start:</p>
<ul>
<li><p><em>Take an educated guess</em>: Perhaps you have taken part in or <a href="https://journals.sagepub.com/doi/pdf/10.4103/0253-7176.116232">read about</a> similar research before. What order of magnitude seems right for this sort of experiment?</p></li>
<li><p><em>Find a source</em>: Sample size estimation is a common topic in introductory statistics textbooks. These often include formulas that students can use to compute sample size for specific categories of questions.</p></li>
<li><p><em>Google it</em>: There are many web-based resources (including online calculators) that are designed to enable sample size calculations. Search engines provide a starting point for finding such resource Doing so, you might end up at a website <a href="https://researchmethodsresources.nih.gov/grt-calculator">like this</a> or <a href="https://www.abs.gov.au/websitedbs/d3310114.nsf/home/sample+size+calculator">like this</a>.</p></li>
</ul>
<p>Or, <strong>if you’d like to skip this step</strong>, we’ll suggest a sample size of 100.</p>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Now, try to estimate the sample size using one of these approaches. What obstacles did you encounter along the way?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>Sample size calculations aren’t always easy or obvious, even for veteran researchers!</p></li>
<li><p>Here’s a <a href="https://www.youtube.com/watch?v=Hz1fyhVOjr4">good video of the challenge</a>.</p></li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Given the description of the scientific hypothesis and experiment, think about what data you would collect and what analyses you would perform to test the hypothesis.
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>What types of values do you expect for each variable? What are their distributions, do you think?</p></li>
<li><p>How do you expect the variables to be related?</p></li>
<li><p>Try drawing a sketch of what you imagine a successful result might look like?</p></li>
<li><p>(Text) For each participant, we will collect expression levels of substance <span class="math inline">\(x\)</span> and age at death.</p></li>
<li><p>(Text) I expect age at death to increase with <span class="math inline">\(x\)</span>.</p></li>
<li><p>(Multiple Choice) Show different plots of <span class="math inline">\(x\)</span> versus age at death, and ask learner to select the plot most consistent with the hypothesis.</p></li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
We provided very little information and asked you to compute the sample size. What other information do you think would be helpful to estimate the sample size?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li></li>
</ul>
</div>
</div>
</section>
<section id="underpowered-experiments-are-doomed-to-failure." class="level1">
<h1>2- Underpowered experiments are doomed to failure.</h1>
<p>Now that you’ve determined (or guessed) the sample size <code>N</code> for your experiment, let’s perform the experiment.</p>
<p>You collect <code>N</code> samples of data, so that you receive from each individual:</p>
<ul>
<li><p><code>x</code> - a measure of the proposed biomarker for longevity,</p></li>
<li><p><code>lifespan</code> - the individual’s age at death.</p></li>
</ul>
<p>Let’s start by defining our choice for <code>N</code></p>
<div id="qpyodide-insertion-location-1"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>With your chosen sample size <code>N</code>, you do the experiment and collect both <code>x</code> and <code>lifespan</code> for each subject.</p>
<div id="qpyodide-insertion-location-2"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>Let’s start by plotting the data.</p>
<div id="qpyodide-insertion-location-3"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What do you observe? Does the hypothesized relationship between the biomarker <span class="math inline">\(x\)</span> and lifespan appear present in the data?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The data look like a random cloud of points.</li>
<li>It’s very difficult to see the hypothesized relationship between <span class="math inline">\(x\)</span> and lifespan.</li>
</ul>
</div>
</div>
<p>Let’s assess the relationship between the biomarker <code>x</code> and <code>lifespan</code> beyond visual inspection.</p>
<p>There are many ways to do so.</p>
<p>Here, we’ll fit a line to the data and compute the slope.</p>
<div id="qpyodide-insertion-location-4"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
If this code is new to you, don’t worry. Can you find the equation for the line in the code above?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The general equation for a line is <code>y = b + mx</code> where <code>b</code> is the intercept and <code>m</code> is the slope.</li>
<li>Here, we’re interested in the specific line <code>lifespan = b + mx</code>.</li>
<li>In the code above, we represent this equation with the notation <code>lifespan ~ 1 + x</code>. In this notation, we tell Python to estimate the outcome variable <code>lifespan</code> as a function of a constant (with label <code>1</code> in the code) and predictor <code>x</code>. Python then estimates the solution to <code>linespan = b + mx</code> by finding the best values for <code>b</code> (the intercept) and <code>m</code> (the slope).</li>
<li>In the code above, we estimate the slope <code>m</code>, which characterizes the relationship between <code>lifespan</code> and <code>x</code>.</li>
</ul>
</div>
</div>
<p>Now, with the line estimated, we can print the estimated slope, and its p-value.</p>
<div id="qpyodide-insertion-location-5"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>Let’s interpret these numbers:</p>
<section id="slope-estimate" class="level3">
<h3 class="anchored" data-anchor-id="slope-estimate">Slope estimate</h3>
<p><strong>Meaning:</strong> The slope estimate represents the change in the <code>lifespan</code> for a one-unit change in the genetic biomarker <code>x</code>.</p>
<p><strong>Interpretation:</strong> For every one-unit increase the genetic biomarker <code>x</code>, the lifespan is estimated to increase by the <code>slope_estimate</code> in years, on average.</p>
</section>
<section id="standard-error-of-slope-estimate" class="level3">
<h3 class="anchored" data-anchor-id="standard-error-of-slope-estimate">Standard error of slope estimate</h3>
<p><strong>Meaning:</strong> The standard error measures the average amount that the slope estimate varies from the true slope of the population regression line. It indicates the precision of the slope estimate.</p>
<p><strong>Interpretation:</strong> A standard error of <span class="math inline">\(\sigma\)</span>, for example, suggests that the slope estimate could vary by about <span class="math inline">\(2 sigma\)</span> units from the true slope. In our case, the standard error is relatively large compared to the slope estimate. This implies there is a considerable amount of uncertainty in the estimate.</p>
</section>
<section id="p-value" class="level3">
<h3 class="anchored" data-anchor-id="p-value">p-value</h3>
<p><strong>Meaning:</strong> The p-value is used to test the null hypothesis that the slope of the regression line is zero (no relationship between <code>x</code> and <code>lifespan</code>).</p>
<p><strong>Interpretation:</strong> The p-value describes the probability of seeing an effect at least this large if substance <code>x</code> had no relation to lifespan. A p-value of 0.3, for example, is much larger than commonly used thresholds to significance levels (e.g., 0.05). In this case, this means that there is not enough evidence to reject the null hypothesis. In other words, the data do not provide sufficient evidence to conclude that there is a statistically significant relationship between <code>x</code> and <code>lifespan</code>.</p>
<p>There’s much more to say about p-values. If you’re curious, check out <a href="https://github.com/Mark-Kramer/METER-Units/blob/main/METER_P_Values.ipynb">this link</a>.</p>
<p>Let’s also <strong>visualize</strong> the estimated line by plotting it with the data.</p>
<div id="qpyodide-insertion-location-6"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Do you find a significant relationship between the genetic biomarker <code>x</code> and <code>lifespan</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>No.&nbsp;The results suggest that while there is a positive slope, indicating a potential relationship between the genetic biomarker <code>x</code> and <code>lifespan</code>, the high standard error and non-significant p-value imply that this relationship is not statistically significant. Further investigation with more data or additional variables may be needed to draw more definitive conclusions.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Wait, this doesn’t make sense!
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li><p>We’ve applied a standard approach to compute sample size <code>N</code> and performed the experiment using this sample size.</p></li>
<li><p>We see a trend supporting the hypothesized relationship, but it’s not significant.</p></li>
<li><p>Why did we fail to detect a significant relationship?</p></li>
<li><p>What’s going on?</p></li>
</ul>
</div>
</div>
</section>
</section>
<section id="choose-your-own-adventure" class="level1">
<h1>Choose your own adventure …</h1>
<div class="alert alert-block alert-danger">
<p><b>Alert to CENTER:</b> What follows is a “choose your own adventure” format, in the style of the old books. The learner picks an option below to continue (either 3A, 3B, or 3C). Not all choices lead to good outcomes. This supports “replayability” of the Mini (e.g., learner can return and play another path).</p>
</div>
<p>To make sense of these confusing results, we’ll use the data collected to estimate the power and improve our choice of sample size.</p>
<section id="which-path-will-you-pursue-to-compute-the-sample-size" class="level2">
<h2 class="anchored" data-anchor-id="which-path-will-you-pursue-to-compute-the-sample-size">Which path will you pursue to compute the sample size?</h2>
</section>
<section id="a--ill-resample-turn-to-page-3a." class="level2">
<h2 class="anchored" data-anchor-id="a--ill-resample-turn-to-page-3a."><strong>3A-</strong> I’ll resample: <a href="#3A">Turn To Page 3A</a>.</h2>
</section>
<section id="b--ill-build-models-turn-to-page-3b." class="level2">
<h2 class="anchored" data-anchor-id="b--ill-build-models-turn-to-page-3b."><strong>3B-</strong> I’ll build models <a href="#3B">Turn To Page 3B</a>.</h2>
</section>
<section id="c--ill-use-my-current-sample-size-choice-turn-to-page-3c." class="level2">
<h2 class="anchored" data-anchor-id="c--ill-use-my-current-sample-size-choice-turn-to-page-3c."><strong>3C-</strong> I’ll use my current sample size choice <a href="#3C">Turn to Page 3C</a>.</h2>
<hr>
</section>
</section>
<section id="3A" class="level1">
<h1>3A- With resampling you can compute the sample size!</h1>
<p>The data provided in Mini 2 represent one instantiation of the experiment, conducted with a sample size <code>N</code>. While our analysis of these data did not yield evidence to support our hypothesis, they remain extremely useful for our continued investigation into sample size. Specifically, we can leverage these data to estimate the necessary sample size for a subsequent experiment. By implementing a resampling procedure, we will systematically examine how variations in sample size <code>N</code> influence our capacity to detect a significant result, thus optimizing our experimental design for future investigations.</p>
<section id="resampling-procedure-introduction" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-introduction">Resampling procedure (Introduction)</h3>
<p>We’re going to attempt something that seems far-fetched and magical: we’ll generate new data from our existing data. To do so, we’ll implement a nonparametric bootstrap to generate new pseudodata from the observed data.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
A note on the nonparametric bootstrap.
</div>
</div>
<div class="callout-body-container callout-body">
<p>Briefly, there is strong theoretical justification for the nonparametric bootstrap. The fundamental idea is that resampling the data with replacement is equivalent to sampling new pseudodata from the empirical cumulative distribution function (eCDF) of the observed data. For a large sample of independent, identically distributed random variables, the distribution of the pseudodata generated from the eCDF will be close to the true distribution of the data. Note the important caveat that the variables are independent, identically distributed; this assumption fails in many cases, such as for time series. Here, we assume that the genetic biomarker and lifespan from each subject are drawn independently from the same distribution (i.e., the values from a subject are independent, identically distributed variables).</p>
</div>
</div>
</section>
<section id="resampling-procedure-4-steps" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-4-steps">Resampling procedure (4 steps)</h3>
<p>Our resampling procedure consists of 4 steps:</p>
<ol type="1">
<li>Choose a new sample size (call it <code>N_resampled</code>).</li>
<li>Draw a new (random) set of <code>N_resampled</code> labels we can use to index our data (biomarker <span class="math inline">\(x\)</span> and lifespan).</li>
<li>Use these indices to create new pseudodata: a resampled data set.</li>
<li>Compute the relationship (and its statistical significance) between the biomarker <span class="math inline">\(x\)</span> and lifespan in our resampled data.</li>
</ol>
<p>We’ll now describe each step. For a related example, <a href="https://youtu.be/mqDEJyW_z4c?si=heigY8z5PqAjnwKZ">see this video</a>.</p>
</section>
<section id="resampling-procedure-step-1" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-1">Resampling procedure: Step 1</h3>
<p>Our first step is to choose a new sample size. Let’s call it <code>N_resampled</code>.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What will you choose for <code>N_resampled</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Our original choice of sample size resulted in a positive slope estimate, indicating a potential relationship between the genetic biomarker <code>x</code> and <code>lifespan</code>. But, the high standard error and non-significant p-value imply that this relationship is not statistically significant. Further investigation with more data may draw more definitive conclusions. However, to start, let’s fix <code>N_resampled = N</code>, the original sample size.</li>
</ul>
</div>
</div>
<div id="qpyodide-insertion-location-7"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>We’ll start by fixing <code>N_resampled = N</code>, the original sample size. In what follows, we’ll adjust this value and examine the impact.</p>
<p><strong>Thus concludes Step 1 of our resampling procedure.</strong></p>
<hr>
</section>
<section id="resampling-procedure-step-2" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-2">Resampling procedure: Step 2</h3>
<p>Our second step is to draw a random set of <code>N_resampled</code> labels to index our data (biomarker <code>x</code> and <code>lifespan</code>).</p>
<p>To visualize this procedure, imagine we assign each patient in the original data set a number, from <span class="math inline">\(0\)</span> up to <code>N</code>. We then write each number on a marble and place all <code>N</code> marbles in an opaque bag. Each marble is assigned a unique integer value from 0 to <code>N</code>-1. Now, reach your hand into the bag, grab a marble, record its number, and replace the marble in the bag. We assume that each marble is equally likely to be selected at each draw (i.e., there are no special features that allow some marbles to be drawn more often). Repeat this procedure <code>N_resampled</code> times to create a list of <code>N_resampled</code> integers. Notice that after recording the drawn marble’s number, we replace it in the bag. So, we could potentially draw the same marble <code>N_resampled</code> times, although that’s extremely unlikely.</p>
<p>Performing this sampling with replacement procedure by hand would, of course, be extremely time consuming (e.g., who will paint integers on each marble?). Fortunately, this is the type of boring task where a computer excels.</p>
<p>Let’s have a look at this “marble draw”:</p>
<div id="qpyodide-insertion-location-8"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Look at the values in <code>ind</code>. What do they mean?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>There are <code>N_resampled</code> values in the vector <code>ind</code>. That’s because we draw <code>N_resampled</code> marbles.</li>
<li>These are the indices to our original data set. You can think of these as numbers indicating participants in the study (e.g., Participant 1, Participant 10, Participating 102, …)</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Run the code to generate <code>ind</code> again. What do you find? (I.e., is it the same or different than the first time?)
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Because we draw random sets of indices, the values in <code>ind</code> will differ each time we run the code.</li>
</ul>
</div>
</div>
<p>We can now generate a set of random indices to our data. We’ll use these to create pseudodata in the next step.</p>
<p><strong>Thus concludes Step 2 of our resampling procedure.</strong></p>
<hr>
</section>
<section id="resampling-procedure-step-3" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-3">Resampling procedure: Step 3</h3>
<p>Our third step is to use these indices to generate the resampled data. To do so, we’ll draw data from the study participants using the indices in <code>ind</code>. Again, this is a task for a computer:</p>
<div id="qpyodide-insertion-location-9"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
How many values are in the resampled data <code>x_sampled</code> and <code>lifespan_resampled</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>There are <code>N_resampled</code> values in resampled data. That’s because we’re usig the vector <code>ind</code> to resample the data, and we drew <code>N_resampled</code> marbles.</li>
</ul>
</div>
</div>
<p>Let’s see what those values look like, compared to our original data set.</p>
<div id="qpyodide-insertion-location-10"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compare the plots of the original data (<code>x</code> and <code>lifespan</code>) with the pseudodata (<code>x_resampled</code> and <code>lifespan_resampled</code>). What do you observe? Do the pseudodata “look like” the original data?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The pseudodata overlaps the original data. That makes sense because we draw the pseudodata from the original data.</li>
<li>By chance, we draw some of the original data multiple times, and other original data not at all.</li>
</ul>
</div>
</div>
<p>We can now generate pseudodata from our original data. We’ll assess the relationship between these pseudodata in the next step.</p>
<p><strong>Thus concludes Step 3 of our resampling procedure.</strong></p>
<hr>
</section>
<section id="resampling-procedure-step-4" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-4">Resampling procedure: Step 4</h3>
<p>Our fourth step is to compute the relationship (and its statistical significance) between the resampled biomarker <span class="math inline">\(x\)</span> and resampled lifespan.</p>
<p>To do so, we’ll follow the same approach as above. We’ll fit the same line to new resampled data, and again compute the slope and significance.</p>
<div id="qpyodide-insertion-location-11"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Are the slope estimate in the original data and resampled data similar or different? What about the standard errors in the estimates?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The slope estimates are similar (near 1).</li>
<li>The standard error estimates are similar (near 1).</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
So far, we’ve fixed <code>N_resampled = N</code>, the original sample size. Change <code>N_resampled</code> and repeat Modeling Steps 2,3,4 to generate results from multiple “experiments”. Do you ever find a significant result? How often do the p-values you find reach your desired level of statistical significance? How does this depend on the value <code>N_resampled</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Yes, now we can sometimes find p&lt;0.05 in the modeled data when <code>N_resampled</code> is large (e.g., 1000).</li>
</ul>
</div>
</div>
<p>We’ve now marched through the entire modeling procedure.</p>
<p>As a final step of this procedure, we’ll use this modeling approach to estimate the statsitcal power of our original experiment and a good sample size for increased power.</p>
<p><strong>Thus concludes Step 4 of our resampling procedure.</strong></p>
<hr>
</section>
<section id="putting-it-all-together" class="level3">
<h3 class="anchored" data-anchor-id="putting-it-all-together">Putting it all together</h3>
<p>We’ll now use resampling to determine a good sample size for our experiment.</p>
<p>To do so, we’ll first introduce the concept of <strong>statistical power</strong>.</p>
<p>In the context of statistical analysis, power and sample size are closely interrelated concepts.</p>
<p><strong>Statistical Power</strong> is the probability that a test will correctly reject a false null hypothesis (i.e., detect an effect if there is one). Higher power reduces the risk of a Type II error, where a real effect is missed (failing to reject a false null hypothesis).</p>
<p>Our initial challenge was to compute the <strong>sample size</strong>: the number of observations or data points included in a study. Our initial choice <code>N</code> was too small; with this choice, we did not detect a significant relationship between the biomarker <code>x</code> and lifespan, i.e., we did not have enough <strong>statistical power</strong>.</p>
<p>Using resampling, we generated pseudodata with an increased sample size <code>N_resampled</code>. Doing so in the exercise above, you might have found (sometimes) a significant relationship between the siualted biomarker <code>x</code> and simulated lifespan; you might have (sometimes) found p&lt;0.05, the arbitrary magical threshold often used to declare a significant effect. If you’d like to understand this magic, check out [LINKS TO OTHER METERS].</p>
<p>We can use this same resampling procedure to compute the statistical power of our test given the sample size. We’ll do so in a few steps:</p>
</section>
<section id="resampling-procedure-to-estimate-the-statistical-power-6-steps" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-to-estimate-the-statistical-power-6-steps">Resampling procedure to estimate the statistical power (6 steps)</h3>
<ol type="1">
<li>Choose a new sample size (call it <code>N_resampled</code>).</li>
<li>Draw a new (random) set of <code>N_resampled</code> labels we can use to index our data (biomarker <span class="math inline">\(x\)</span> and lifespan).</li>
<li>Use these indices to create new pseudodata: a resampled data set.</li>
<li>Compute statistical significance (p-value) between the biomarker <span class="math inline">\(x\)</span> and lifespan in our resampled data.</li>
<li>Repeat Steps 1-5 <code>K</code> times, saving the p-value each time.</li>
<li>The <strong>statistical power</strong> is the proportion of p-values below a chosen threshold <code>alpha</code>.</li>
</ol>
<p>That’s a lot of steps! Let’s break them down:</p>
</section>
<section id="resampling-procedure-steps-1-4" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-steps-1-4">Resampling procedure: Steps 1-4</h3>
<p>You’ve already done steps 1-4 when performing resampling to create pseudodata! Nothing new to see here.</p>
</section>
<section id="resampling-procedure-step-5" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-5">Resampling procedure: Step 5</h3>
<p>We’ve added Step 5, in which we create <code>K</code> new instances of the pseudodata. For each instance, we calculate and save the p-value corresponding to the statistical significance of the relationship between the biomarker <span class="math inline">\(x\)</span> and lifespan in our resampled data.</p>
<p>At the end of Step 5, we’ll have created a vector of <code>K</code> p-values. Let’s do so now:</p>
<div id="qpyodide-insertion-location-12"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>Let’s investigate this list of p-values by plotting a historgram:</p>
<div id="qpyodide-insertion-location-13"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What p-values do you observe?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>P-values extend from near 0 to near 1.</li>
<li>P-values are slightly more concentrated near 0, but extend to cover the entire range.</li>
</ul>
</div>
</div>
</section>
<section id="resampling-procedure-step-6" class="level3">
<h3 class="anchored" data-anchor-id="resampling-procedure-step-6">Resampling procedure: Step 6</h3>
<p>Our last step to compute the statistical power is the proportion of p-values below a chosen threshold <code>alpha</code>.</p>
<p>The threshold <code>alpha</code> represents the threshold for rejecting the null hypothesis when it is actually true. It’s conventional to set</p>
<p><code>alpha = 0.05</code></p>
<p>which means that there is a 5% chance of committing a Type I error, which is the error of incorrectly rejecting a true null hypothesis. This value is not inherently magical or optimal in all circumstances. But, it has become a convention primarily because it offers a middle ground that has been deemed acceptable by the scientific community for controlling Type I errors.</p>
<p>To implement Step 6, let’s compute the <code>statistical_power</code> as the proportion of times that <code>p_values</code> is less than the threshold <code>alpha</code>.</p>
<div id="qpyodide-insertion-location-14"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Interpret the value in <code>statistical_power</code>. What does it mean?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>This value represents the proportion of times we drew pseudodata and detected a significant relationship between the biomarker <code>x</code> and lifespan.</li>
</ul>
</div>
</div>
<p>The value in <code>statistical_power</code> is the <strong>statistical power</strong> of our test. It represents the proportion of times we reject the null hypothesis and declare a significant relationship between the biomarker <code>x</code> and lifespan.</p>
<p>To make this graphically explicit, let’s replot the histogram of <code>p-values</code> with a line at our threshold <code>alpha</code>.</p>
<div id="qpyodide-insertion-location-15"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>In this plot, the <strong>statistical power</strong> is the proportion of values to the left (i.e., smaller than) the red line.</p>
<p>And that’s it!</p>
<p>The <strong>statistical power</strong> is not a mystical quantity. It’s the probability that a test will correctly reject a false null hypothesis. And, using the data we collected, we can compute this <strong>statistical power</strong> for different choices of sample size (<code>N_resample</code>).</p>
<p>Let’s collect all the code, and perform one more experiment:</p>
<div id="qpyodide-insertion-location-16"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
We’ve used our original sample size by setting <code>N_resampled = N</code> in the code above. What is the statistical power? Does this make sense with our original conclusion in Mini 2?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Using our original sample size (<code>N=100</code>), the statistical power is small, less than 0.15.</li>
<li>The probability that the test will correctly reject a false null hypothesis (here, no relationship between biomarker <span class="math inline">\(x\)</span> and longevitiy) is 0.15. That’s not very high …</li>
<li>Therefore, with this sample size, we do not expect enough power to detect a significant effect.</li>
<li>This is consistent with the results in Mini 2, in which we failed to detect a significant effect.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Increase <code>N_resampled</code> in the code above. What happens to the statistical power?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Statistical power increases with <code>N_resampled</code>.</li>
<li>Larger samples provide more information about the population, leading to more precise estimates of the population parameters. This precision reduces the standard error and widens the gap between the null hypothesis and the alternative hypothesis if there is a true effect, making it easier to detect significant differences. Therefore, increasing the sample size typically increases the power of a statistical test.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
At what value of <code>N_resampled</code> does the statistical power equal 0.80?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>At approximately <code>N_resampled</code> = 1000, the statistical power equals 0.80.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why do we choose statistical power 0.8?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Choosing a statistical power of 0.8, or 80%, is a common convention in many fields of research, particularly in the social and biomedical sciences.</p>
<p>Statistical power is the probability of correctly rejecting a false null hypothesis, thus avoiding a Type II error. A power of 0.8 means there is a 20% chance of a Type II error (failing to detect a true effect). Setting the power at 0.8 provides a reasonable balance between the risks of Type I errors (false positives) and Type II errors (false negatives). Researchers often choose a 5% (<code>alpha=0.05</code>) significance level for Type I errors, aiming to maintain a pragmatic yet cautious approach to declaring findings.</p>
<p>Increasing power beyond 0.8 generally requires larger sample sizes, which can escalate the costs and logistical complexity of a study. The choice of 0.8 is considered a good trade-off between increasing precision and controlling operational constraints.</p>
<p>The 0.8 level has become somewhat of a standard through historical precedent and its endorsement in statistical texts and guidelines. Researchers often follow these conventions to align with accepted practices, making their studies comparable to others in the field.</p>
</div>
</div>
</section>
<section id="turn-to-page-4-summary" class="level2">
<h2 class="anchored" data-anchor-id="turn-to-page-4-summary">Turn to Page 4 <a href="#Summary">Summary</a></h2>
</section>
</section>
<section id="3B" class="level1">
<h1>3B- Build models to compute the sample size!</h1>
<p>The data provided in Mini 2 represent one instantiation of the experiment, conducted with a sample size <code>N</code>. While our analysis of these data did not yield evidence to support our hypothesis, they remain extremely useful for our continued investigation into sample size. Specifically, we can leverage these data to estimate the necessary sample size for a subsequent experiment. By estimating models of these data, we will systematically examine how variations in sample size <code>N</code> influence our capacity to detect a significant result, thus optimizing our experimental design for future investigations.</p>
<section id="modeling-procedure-introduction" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-introduction">Modeling procedure (Introduction)</h3>
<p>We’re going to attempt something that seems far-fetched and magical: we’ll generate new data from our existing data. To do so, we’ll estimate models from the existing data, and use those models to simulate new synthetic data.</p>
</section>
<section id="modeling-procedure-4-steps" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-4-steps">Modeling procedure (4 steps)</h3>
<p>Our modeling procedure consists of 4 steps:</p>
<ol type="1">
<li>Estimate a model for biomarker <code>x</code>.</li>
<li>Estimate a model of the relationship between biomarker <code>x</code> and lifespan.</li>
<li>Choose a new sample size (call it <code>N_modeled</code>) and simulate data from the models.</li>
<li>Compute the relationship (and its statistical significance) between the simulated biomarker <span class="math inline">\(x\)</span> and lifespan.</li>
</ol>
<p>We’ll now describe each step.</p>
</section>
<section id="modeling-procedure-step-1" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-1">Modeling procedure: Step 1</h3>
<p>Our first step is to estimate a model for biomarker <code>x</code>.</p>
<p>To do so, let’s begin by visualizing the biomarker <code>x</code> in a historgram:</p>
<div id="qpyodide-insertion-location-17"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Describe the histogram. What does it look like?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The histogram has most values near 0, with fewer values near +/- 2.</li>
<li>It’s approximately bell-shaped.</li>
<li>It’s looks “normal” or “Gaussian”.</li>
</ul>
</div>
</div>
<p>We conclude that the values for biomarker <code>x</code> look approximately <a href="https://en.wikipedia.org/wiki/Normal_distribution">normally distributed</a>.</p>
<p>That’s very useful, because it suggests we can model the data as normally distributed.</p>
<p>Normal distributions are nice because we only need to estimate two parameters: <strong>the mean and standard deviation</strong>.</p>
<p>Let’s compute those values in Python:</p>
<div id="qpyodide-insertion-location-18"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Interpert the values of <code>mean_x</code> and <code>std_x</code>. How do they compare to the histogram of biomarker <code>x</code> plotted above?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The mean of the distribution for biomarker <code>x</code> is very close to zero. This suggests that on average, the values in the biomarker center around zero, consistent with our visualization of the data in the histogram.</li>
<li>The standard deviation measures the dispersion or spread of the data points around the mean. A standard deviation of 0.71 indicates that the typical deviation from the mean biomarker values is about 0.71 units. For a normal distribution, we expect about 68% of the data to fall within one standard deviation of the mean (i.e., between -0.68 and 0.74), and about 95% of the data to fall within two standard deviations (i.e., between -1.39 and 1.45). Those ranges appear are consistent with our visualization of the data in the histogram.</li>
</ul>
</div>
</div>
<p>Now, with these two parameters estimated, we’ve completely specificed our model of biomarker <code>x</code>.</p>
<p>In words, we’ll model <code>x</code> as normally distributed with mean <code>mean_x</code> = 0.03 and standard deviation <code>std_x</code> = 0.71.</p>
<p>In Python, it’s <strong>easy to simulate values from this model.</strong></p>
<p>Let’s do so, and simulate 100 values from the model.</p>
<div id="qpyodide-insertion-location-19"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compared <code>x_modeled</code> to the original values <code>x</code>. Do the values appear consistent?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Yes. In <code>x_modeled</code> there are many values near 0, and few values near +/- 2.</li>
</ul>
</div>
</div>
<p>Let’s also plot histograms for the original data <code>x</code> and the modeled data <code>x_modeled</code>.</p>
<div id="qpyodide-insertion-location-20"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compared the histograms of <code>x_modeled</code> and the original values <code>x</code>. Do the histograms appear consistent?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Yes. In <code>x_modeled</code> there are many values near 0, and few values near +/- 2.</li>
</ul>
</div>
</div>
<p><strong>Thus concludes Step 1 of our modeling procedure.</strong></p>
<p>We’ve modeled the biomarker <code>x</code> as normally distributed, with mean and standard deviation estimated from our observed data.</p>
<hr>
</section>
<section id="modeling-procedure-step-2" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-2">Modeling procedure: Step 2</h3>
<p>Our second step is to estimate a model of the lifespan.</p>
<p>Thankfully, we’ve already completed this step!</p>
<p>In Mini 2, we modeled the relationship between biomarker <span class="math inline">\(x\)</span> and lifespan as a line.</p>
<p>Here’s that code again:</p>
<div id="qpyodide-insertion-location-21"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>As we discussed in Mini 2, the model consists of two parameters: the <code>slope</code> and <code>intercept</code>.</p>
<p>Let’s define and print those:</p>
<div id="qpyodide-insertion-location-22"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>Do those values make sense?</p>
<p>Let’s check by plotting the data with our estimated line:</p>
<div id="qpyodide-insertion-location-23"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Examine the plot above. Do the estimated values for <code>slope</code> and <code>intercept</code> make sense?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The intercept is the value of <code>lifespan</code> when <code>x=0</code>. Looking at the plot, this occurs near 73 years, consistent with the value of intercept.</li>
<li>The line has a small upward tilt. This indicates the lifespan increases a tiny bit for each unit increase in biomarker <span class="math inline">\(x\)</span>, consistent with the slope of 0.91.</li>
</ul>
</div>
</div>
<p>To simulate the model of lifespan, we’ll need to extract one more parameter from the estimated model: the <strong>dispersion</strong>.</p>
<p>The <strong>dispersion parameter</strong> describes the amount of uncertainty in our ability to predinct each data point. In this case, it is the residual standard deviation of the lifespan after we have tried to predict it using the expression level of substance <span class="math inline">\(x\)</span>.</p>
<p>Let’s get the dispersion from the estimated model:</p>
<div id="qpyodide-insertion-location-24"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<em>Programming aside</em>
</div>
</div>
<div class="callout-body-container callout-body">
<p>We calculate the dispersion parameter using the <code>np.sqrt(model.scale)</code> formula from the fitted Ordinary Least Squares (OLS) model. In the context of an OLS model, the <code>model.scale</code> attribute reflects the variance of the residuals (errors), and taking the square root of this variance gives you the standard deviation.</p>
</div>
</div>
<p>In general the dispersion (or standard deviation) tells us how much the residuals (differences between observed and predicted values) are spread out around the mean of the residuals. A higher value indicates a greater spread, suggesting more variability in the errors.</p>
<p>In this case, a dispersion value of 7.22 means that, on average, the actual <code>lifespan</code> values deviate from the values predicted by our model by about 7.22 units. This indicates an average error magnitude of approximately 7 years from the predicted lifespan based on your model.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
So, the dispersion parameter indicates how well my model fits the data. Don’t I want the dispersion to be 0?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>In general, we do <em>not</em> expect the dispersion parameter to be 0. Our model represents a simplification of the data: we’re using a simple line to capture the relationship between biomarker <span class="math inline">\(x\)</span> and lifespan. We do <em>not</em> expect this line to capture every nuance of the relationship; these are complicated biological entities with complex relationships. So, we’re happy with a non-zero dispersion.</li>
</ul>
</div>
</div>
<p><strong>Thus concludes Step 2 of our modeling procedure.</strong></p>
<p>With the 3 estimated model parameters, we can now simulate values of lifespan from the model. We’ll do so in the next step.</p>
<hr>
</section>
<section id="modeling-procedure-step-3" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-3">Modeling procedure: Step 3</h3>
<p>Our next step is to choose a new sample size (call it <code>N_modeled</code>) and simulate data from our models.</p>
<p>With the our models estiamted from the original data, we can now simulate realizations of models.</p>
<p>To do so, we’ll evaluate these model:</p>
<p><code>x_modeled        = np.random.normal(loc=mean_x, scale=std_x, size=N_modeled)</code></p>
<p><code>lifespan_modeled = intercept + slope * x_modeled + np.random.normal(loc=0.0, scale=dispersion, size=N_modeled)</code></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Describe - in words - each term in the equations above.
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>What variables do you recognize?</li>
<li>What variables are now?</li>
<li>What is the equation doing?</li>
</ul>
</div>
</div>
<p>The first equation should look familiar … it’s our model of biomarker <code>x</code>, described in Step 2.</p>
<p>The second equation might also look familar … it’s the linear model we originally estimated data, with an added random noise component to simulate data.</p>
<p>Here’s a breakdown of each term in the second equation:</p>
<ul>
<li><p><strong>lifespan_modeled</strong>: This is the dependent variable in the equation, representing the predicted values of lifespan based on the model. This variable is being assigned the values calculated by the formula on the right-hand side.</p></li>
<li><p><strong>intercept</strong>: This is the intercept of the linear model. It represents the value of the dependent variable (<code>lifespan_modeled</code>) when the independent variable (<code>x</code>) is zero.</p></li>
<li><p><strong>slope</strong>: This term is the coefficient of the independent variable <code>x</code> in the linear model. It measures the amount by which <code>lifespan_modeled</code> is expected to increase for a one-unit increase in <code>x</code>. It represents the steepness or incline of the regression line.</p></li>
<li><p><strong>x</strong>: This is the independent variable or predictor in the model. Here we use biomarker ‘x’ to predict <code>lifespan_modeled</code>. We assume the relationship between <code>x</code> and <code>lifespan_modeled</code> is linear in this model.</p></li>
<li><p><strong>np.random.normal(loc=0.0, scale=dispersion, size=[N_modeled,1])</strong>: This</p></li>
<li><p>function generates random noise added to the linear model, simulating variability in the data that is not explained by the independent variable <code>x</code> alone:</p>
<ul>
<li><strong>loc=0.0</strong>: This specifies the mean of the normal distribution from which the random noise is drawn. A mean of 0 indicates that the noise is centered around zero, adding no systematic bias to the predictions, just variability.</li>
<li><strong>scale=dispersion</strong>: This is the standard deviation of the normal distribution. It controls the variability of the noise added to the model. The term dispersion here is whate we calculated above, representing the standard deviation of the residuals in the linear model.</li>
<li><strong>size=[N_modeled,1]</strong>: This specifies the shape of the array of random values generated. <code>N_modeled</code> is the number of observations or samples for which you are modeling lifespan_modeled. The [N_modeled,1] format makes the output an N_modeled-by-1 array, where each element is a random noise value added to the corresponding model prediction.</li>
</ul></li>
</ul>
<p>With the estimated models in hand, it’s now simple to simulate data from the models.</p>
<p>To do so, we must choose a value for <code>N_modeled</code>.</p>
<p>Let’s start by setting <code>N_modeled = N</code>, our original sample size, and then simulate the models. To do so,</p>
<div id="qpyodide-insertion-location-25"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
How many values are in the simulated data <code>x_sampled</code> and <code>lifespan_resampled</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>There are <code>N_resampled</code> values in resampled data. That’s because we’re usig the vector <code>ind</code> to resample the data, and we drew <code>N_resampled</code> marbles.</li>
</ul>
</div>
</div>
<p>Let’s see what those modeled values look like, compared to our original data set.</p>
<div id="qpyodide-insertion-location-26"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Compare the plots of the original data (<code>x</code> and <code>lifespan</code>) with the modeled data (<code>x_modeled</code> and <code>lifespan_modeled</code>). What do you observe? Do the modeled data “look like” the original data?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The modeled data overlap the original data. The two sets of data have appoximately the same range of biomarker values (from -2 to 2) and lifespan values (from 55 to 90 years).</li>
</ul>
</div>
</div>
<p><strong>Thus concludes Step 3 of our modeling procedure.</strong></p>
<p>We can now simulate data from our models. We’ll assess the relationship between these simulated values in the next step.</p>
<hr>
</section>
<section id="modeling-procedure-step-4" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-4">Modeling procedure: Step 4</h3>
<p>Our fourth step is to compute the relationship (and its statistical significance) between the modeled biomarker <span class="math inline">\(x\)</span> and modeled lifespan.</p>
<p>To do so, we’ll follow the same approach as above. We’ll fit the same line to new modeled data, and again compute the slope and significance.</p>
<div id="qpyodide-insertion-location-27"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Are the slope estimate in the original data and modeled data similar or different? What about the standard errors in the estimates?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The slope estimates are similar (near 1).</li>
<li>The standard error estimates are similar (also near 1).</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
So far, we’ve fixed <code>N_modeled = N</code>, the original sample size. Change <code>N_modeled</code> and repeat Modeling Steps 2,3,4 to generate results from multiple “experiments”. Do you ever find a significant result? How often do the p-values you find reach your desired level of statistical significance? How does this depend on the value <code>N_modeled</code>?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Yes, now we can sometimes find p&lt;0.05 in the modeled data when <code>N_modeled</code> is large (e.g., 1000).</li>
</ul>
</div>
</div>
<p><strong>Thus concludes Step 4 of our modeling procedure.</strong></p>
<p>We’ve now marched through the entire modeling procedure.</p>
<p>As a final step of this procedure, we’ll use this modeling approach to estimate the statsitcal power of our original experiment and a good sample size for increased power.</p>
<hr>
</section>
<section id="now-lets-use-this-modeling-approach-to-determine-a-good-sample-size-for-our-experiment." class="level3">
<h3 class="anchored" data-anchor-id="now-lets-use-this-modeling-approach-to-determine-a-good-sample-size-for-our-experiment.">Now, let’s use this modeling approach to determine a good sample size for our experiment.</h3>
<p>To do so, we’ll first introduce the concept of <strong>statistical power</strong>.</p>
<p>In the context of statistical analysis, power and sample size are closely interrelated concepts.</p>
<p><strong>Statistical Power</strong> is the probability that a test will correctly reject a false null hypothesis (i.e., detect an effect if there is one). Higher power reduces the risk of a Type II error, where a real effect is missed (failing to reject a false null hypothesis).</p>
<p>Our initial challenge was to compute the <strong>sample size</strong>: the number of observations or data points included in a study. Our initial choice <code>N</code> was too small; with this choice, we did not detect a significant relationship between the biomarker <code>x</code> and lifespan, i.e., we did not have enough <strong>statistical power</strong>.</p>
<p>Using our modeling approach, we can generate simulated data with an increased sample size <code>N_modeled</code>. Doing so in the exercise above, you might have found (sometimes) a significant relationship between the siualted biomarker <code>x</code> and simulated lifespan; you might have (sometimes) found p&lt;0.05, the arbitrary magical threshold often used to declare a significant effect. If you’d like to understand this magic, check out [LINKS TO OTHER METERS].</p>
<p>We can use this same modeling procedure to compute the statistical power of our test given the sample size. We’ll do so in a few steps:</p>
</section>
<section id="modeling-procedure-to-estimate-the-statistical-power-6-steps" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-to-estimate-the-statistical-power-6-steps">Modeling procedure to estimate the statistical power (6 steps)</h3>
<ol type="1">
<li>Estimate a model for biomarker <code>x</code>.</li>
<li>Estimate a model of the relationship between biomarker <code>x</code> and lifespan.</li>
<li>Choose a new sample size (call it <code>N_modeled</code>) and simulate data from the models.</li>
<li>Compute the relationship (and its statistical significance) between the simulated biomarker <span class="math inline">\(x\)</span> and lifespan.</li>
<li>Repeat Steps 1-4 <code>K</code> times, saving the p-value each time.</li>
<li>The <strong>statistical power</strong> is the proportion of p-values below a chosen threshold <code>alpha</code>.</li>
</ol>
<p>That’s a lot of steps! Let’s break them down:</p>
</section>
<section id="modeling-procedure-steps-1-4" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-steps-1-4">Modeling procedure: Steps 1-4</h3>
<p>You’ve already done Steps 1-4 when creating the models to generate simulated data. Nothing new to see here.</p>
</section>
<section id="modeling-procedure-step-5" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-5">Modeling procedure: Step 5</h3>
<p>We’ve added Step 5, in which we create <code>K</code> new instances of the modeled data. For each instance, we calculate and save the p-value corresponding to the statistical significance of the relationship between the biomarker <span class="math inline">\(x\)</span> and lifespan in our modeled data.</p>
<p>At the end of Step 5, we’ll have created a vector of <code>K</code> p-values. Let’s do so now, with <code>N_modeled=N</code>.</p>
<div id="qpyodide-insertion-location-28"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>Let’s investigate this list of p-values by plotting a historgram:</p>
<div id="qpyodide-insertion-location-29"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
What p-values do you observe?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>P-values extend from near 0 to near 1.</li>
<li>P-values are slightly more concentrated near 0, but extend to cover the entire range.</li>
</ul>
</div>
</div>
</section>
<section id="modeling-procedure-step-6" class="level3">
<h3 class="anchored" data-anchor-id="modeling-procedure-step-6">Modeling procedure: Step 6</h3>
<p>Our last step to compute the statistical power is the proportion of p-values below a chosen threshold <code>alpha</code>.</p>
<p>The threshold <code>alpha</code> represents the threshold for rejecting the null hypothesis when it is actually true. It’s conventional to set</p>
<p><code>alpha = 0.05</code></p>
<p>which means that there is a 5% chance of committing a Type I error, which is the error of incorrectly rejecting a true null hypothesis. This value is not inherently magical or optimal in all circumstances. But, it has become a convention primarily because it offers a middle ground that has been deemed acceptable by the scientific community for controlling Type I errors.</p>
<p>To implement Step 6, let’s compute the <code>statistical_power</code> as the proportion of times that <code>p_values</code> is less than the threshold <code>alpha</code>.</p>
<div id="qpyodide-insertion-location-30"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Question :</strong> Interpret the value in <code>statistical_power</code>. What does it mean?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>This value represents the proportion of times we created simualted data and detected a significant relationship between the biomarker <code>x</code> and lifespan.</li>
</ul>
</div>
</div>
<p>The value in <code>statistical_power</code> is the <strong>statistical power</strong> of our test. It represents the proportion of times we reject the null hypothesis and declare a significant relationship between the biomarker <code>x</code> and lifespan.</p>
<p>To make this graphically explicit, let’s replot the histogram of <code>p-values</code> with a line at our threshold <code>alpha</code>.</p>
<div id="qpyodide-insertion-location-31"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<p>In this plot, the <strong>statistical power</strong> is the proportion of values to the left (i.e., smaller than) the red line.</p>
<p>And that’s it!</p>
<p>The <strong>statistical power</strong> is not a mystical quantity. It’s the probability that a test will correctly reject a false null hypothesis.</p>
<p>And, using the data we collected, we can compute how the <strong>statistical power</strong> depends on sample size by changing the value of (<code>N_modeled</code>).</p>
<p>To that end, let’s collect all the code, and perform one more experiment:</p>
<div id="qpyodide-insertion-location-32"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
We’ve used our original sample size by setting <code>N_modeled = N</code> in the code above. What is the statistical power? Does this make sense with our original conclusion in Mini 2?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Using our original sample size (N=100), the statistical power is small, near 0.15.</li>
<li>Therefore, with this sample size, we do not expect enough power to detect a significant effect.</li>
<li>This is consistent with the results in Mini 2, in which we failed to detect a significant effect.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Now, use this code to determine the value at which <code>N_modeled</code> produces statistical power equal to 0.80?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>At approximately <code>N_modeled</code> = 1000, the statistical power equals 0.80.</li>
</ul>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why do we choose statistical power 0.8?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Choosing a statistical power of 0.8, or 80%, is a common convention in many fields of research, particularly in the social and biomedical sciences.</p>
<p>Statistical power is the probability of correctly rejecting a false null hypothesis, thus avoiding a Type II error. A power of 0.8 means there is a 20% chance of a Type II error (failing to detect a true effect). Setting the power at 0.8 provides a reasonable balance between the risks of Type I errors (false positives) and Type II errors (false negatives). Researchers often choose a 5% (<code>alpha=0.05</code>) significance level for Type I errors, aiming to maintain a pragmatic yet cautious approach to declaring findings.</p>
<p>Increasing power beyond 0.8 generally requires larger sample sizes, which can escalate the costs and logistical complexity of a study. The choice of 0.8 is considered a good trade-off between increasing precision and controlling operational constraints.</p>
<p>The 0.8 level has become somewhat of a standard through historical precedent and its endorsement in statistical texts and guidelines. Researchers often follow these conventions to align with accepted practices, making their studies comparable to others in the field.</p>
</div>
</div>
</section>
<section id="turn-to-page-4-summary." class="level2">
<h2 class="anchored" data-anchor-id="turn-to-page-4-summary.">Turn to Page 4 <a href="#Summary">Summary</a>.</h2>
<hr>
</section>
</section>
<section id="3C" class="level1">
<h1>3C- Do nothing, I’m happy with the current sample size choice</h1>
<div id="qpyodide-insertion-location-33"></div>
<noscript>Please enable JavaScript to experience the dynamic code cell content on this page.</noscript>
</section>
<section id="Summary" class="level1">
<h1>4- Summary</h1>
<p>We’ve done something remarkable.</p>
<p>We began with <code>N</code> observations in our original data set. Analyzing these data, we failed to detect a significant relationship between the biomarker <span class="math inline">\(x\)</span> and lifespan.</p>
<p>Rather than abandoning these data, we instead repurposed these data to perform a sample size calculation.</p>
<p>Depending on the adventure you choose, you (hopefully) used the original data to:</p>
<ul>
<li><p>3A: Resample the data to create pseudodata with different sample sizes <code>N_resample</code>.</p></li>
<li><p>3B: Model the data to create simualted data with different sample sizes <code>N_modeled</code>.</p></li>
</ul>
<p>We repeated this procedure to compute the <strong>statistical power</strong>: the proportion of times we reject the null hypothesis.</p>
<p>This procedure provides a more direct, intuitive approach to computing the <strong>statistical power</strong>.</p>
<p>If you have some data, you can compute the sample size!</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Okay, I get it. When I have some data, I can use it to estimate a sample size for a future experiment But what if I do <em>not</em> have any data. Then how would I compute the sample size?
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Good question. A meanigful sample size calculation requires:
<ol type="1">
<li>A hypothesis, and</li>
<li>Knowledge of your data.</li>
</ol></li>
</ul>
<p>Before planning your experiment, you’ll certainly know <em>something</em> about your data. The challenge then is to use that <em>something</em> to estimate sample size.</p>
<p>If you’re interested in learning more about this scenario, check out the full Unit.</p>
</div>
</div>
<div class="alert alert-block alert-info">
<p><em>Conclusions</em>:</p>
<ul>
<li>Beginning with some data, you can use resample or simulate the data to estimate the statistical power of your test.</li>
<li>You can apply this process to compute the statistical power for different sample sizes.</li>
<li>You can apply this process to determine the sample size that acheives a desired statistical power (typically 0.8).</li>
</ul>
</div>
<div class="alert alert-block alert-danger">
<b>Warning:</b>
<p></p>
<p>In this example, we were lucky that the initial draw of a small sample size produced the expected effect. An unlucky sample may have produced (by chance) an opposite effect. In that case, resampling will not produce meaningful power/sample size results. Preliminary data is often important for future experimental design, but it’s important to consider how variability in a small, preliminary dataset can influence power and sample size estimates.</p>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script type="module">
/**
 * Factory function to create different types of cells based on options.
 * @param {Object} cellData - JSON object containing code, id, and options.
 * @returns {BaseCell} Instance of the appropriate cell class.
 */
globalThis.qpyodideCreateCell = function(cellData) {
    switch (cellData.options.context) {
        case 'interactive':
            return new InteractiveCell(cellData);
        case 'output':
            return new OutputCell(cellData);
        case 'setup':
            return new SetupCell(cellData);
        default:
            return new InteractiveCell(cellData);
            // throw new Error('Invalid cell type specified in options.');
    }
}  

/**
 * CellContainer class for managing a collection of cells.
 * @class
 */
class CellContainer {
    /**
     * Constructor for CellContainer.
     * Initializes an empty array to store cells.
     * @constructor
     */
    constructor() {
        this.cells = [];
    }

    /**
     * Add a cell to the container.
     * @param {BaseCell} cell - Instance of a cell (BaseCell or its subclasses).
     */
    addCell(cell) {
        this.cells.push(cell);
    }

    /**
     * Execute all cells in the container.
     */
    async executeAllCells() {
        for (const cell of this.cells) {
            await cell.executeCode();
        }
    }

    /**
     * Execute all cells in the container.
     */
    async autoRunExecuteAllCells() {
        for (const cell of this.cells) {
            await cell.autoRunExecuteCode();
        }
    }
}
  

/**
 * BaseCell class for handling code execution using Pyodide.
 * @class
 */
class BaseCell {
    /**
     * Constructor for BaseCell.
     * @constructor
     * @param {Object} cellData - JSON object containing code, id, and options.
     */
    constructor(cellData) {
        this.code = cellData.code;
        this.id = cellData.id;
        this.options = cellData.options;
        this.insertionLocation = document.getElementById(`qpyodide-insertion-location-${this.id}`);
        this.executionLock = false;
    }

    cellOptions() {
        // Subclass this? 
        console.log(this.options);
        return this.options;
    }

    /**
     * Execute the Python code using Pyodide.
     * @returns {*} Result of the code execution.
     */
    async executeCode() {
        // Execute code using Pyodide
        const result = getPyodide().runPython(this.code);
        return result;
    }
};

/**
 * InteractiveCell class for creating editable code editor with Monaco Editor.
 * @class
 * @extends BaseCell
 */
class InteractiveCell extends BaseCell {

    /**
     * Constructor for InteractiveCell.
     * @constructor
     * @param {Object} cellData - JSON object containing code, id, and options.
     */
    constructor(cellData) {
        super(cellData);
        this.editor = null;
        this.setupElement();
        this.setupMonacoEditor();
    }

    /**
     * Set up the interactive cell elements
     */
    setupElement() {

        // Create main div element
        var mainDiv = document.createElement('div');
        mainDiv.id = `qpyodide-interactive-area-${this.id}`;
        mainDiv.className = `qpyodide-interactive-area`;
        if (this.options.classes) {
            mainDiv.className += " " + this.options.classes
        }

        // Add a unique cell identifier that users can customize
        if (this.options.label) {
            mainDiv.setAttribute('data-id', this.options.label);
        }

        // Create toolbar div
        var toolbarDiv = document.createElement('div');
        toolbarDiv.className = 'qpyodide-editor-toolbar';
        toolbarDiv.id = `qpyodide-editor-toolbar-${this.id}`;

        // Create a div to hold the left buttons
        var leftButtonsDiv = document.createElement('div');
        leftButtonsDiv.className = 'qpyodide-editor-toolbar-left-buttons';

        // Create a div to hold the right buttons
        var rightButtonsDiv = document.createElement('div');
        rightButtonsDiv.className = 'qpyodide-editor-toolbar-right-buttons';

        // Create Run Code button
        var runCodeButton = document.createElement('button');
        runCodeButton.className = 'btn btn-default qpyodide-button qpyodide-button-run';
        runCodeButton.disabled = true;
        runCodeButton.type = 'button';
        runCodeButton.id = `qpyodide-button-run-${this.id}`;
        runCodeButton.textContent = '🟡 Loading Pyodide...';
        runCodeButton.title = `Run code (Shift + Enter)`;

        // Append buttons to the leftButtonsDiv
        leftButtonsDiv.appendChild(runCodeButton);

        // Create Reset button
        var resetButton = document.createElement('button');
        resetButton.className = 'btn btn-light btn-xs qpyodide-button qpyodide-button-reset';
        resetButton.type = 'button';
        resetButton.id = `qpyodide-button-reset-${this.id}`;
        resetButton.title = 'Start over';
        resetButton.innerHTML = '<i class="fa-solid fa-arrows-rotate"></i>';

        // Create Copy button
        var copyButton = document.createElement('button');
        copyButton.className = 'btn btn-light btn-xs qpyodide-button qpyodide-button-copy';
        copyButton.type = 'button';
        copyButton.id = `qpyodide-button-copy-${this.id}`;
        copyButton.title = 'Copy code';
        copyButton.innerHTML = '<i class="fa-regular fa-copy"></i>';

        // Append buttons to the rightButtonsDiv
        rightButtonsDiv.appendChild(resetButton);
        rightButtonsDiv.appendChild(copyButton);

        // Create console area div
        var consoleAreaDiv = document.createElement('div');
        consoleAreaDiv.id = `qpyodide-console-area-${this.id}`;
        consoleAreaDiv.className = 'qpyodide-console-area';

        // Create editor div
        var editorDiv = document.createElement('div');
        editorDiv.id = `qpyodide-editor-${this.id}`;
        editorDiv.className = 'qpyodide-editor';

        // Create output code area div
        var outputCodeAreaDiv = document.createElement('div');
        outputCodeAreaDiv.id = `qpyodide-output-code-area-${this.id}`;
        outputCodeAreaDiv.className = 'qpyodide-output-code-area';
        outputCodeAreaDiv.setAttribute('aria-live', 'assertive');

        // Create pre element inside output code area
        var preElement = document.createElement('pre');
        preElement.style.visibility = 'hidden';
        outputCodeAreaDiv.appendChild(preElement);

        // Create output graph area div
        var outputGraphAreaDiv = document.createElement('div');
        outputGraphAreaDiv.id = `qpyodide-output-graph-area-${this.id}`;
        outputGraphAreaDiv.className = 'qpyodide-output-graph-area';

        // Append buttons to the toolbar
        toolbarDiv.appendChild(leftButtonsDiv);
        toolbarDiv.appendChild(rightButtonsDiv);

        // Append all elements to the main div
        mainDiv.appendChild(toolbarDiv);
        consoleAreaDiv.appendChild(editorDiv);
        consoleAreaDiv.appendChild(outputCodeAreaDiv);
        mainDiv.appendChild(consoleAreaDiv);
        mainDiv.appendChild(outputGraphAreaDiv);

        // Insert the dynamically generated object at the document location.
        this.insertionLocation.appendChild(mainDiv);
    }

    /**
     * Set up Monaco Editor for code editing.
     */
    setupMonacoEditor() {

        // Retrieve the previously created document elements
        this.runButton = document.getElementById(`qpyodide-button-run-${this.id}`);
        this.resetButton = document.getElementById(`qpyodide-button-reset-${this.id}`);
        this.copyButton = document.getElementById(`qpyodide-button-copy-${this.id}`);
        this.editorDiv = document.getElementById(`qpyodide-editor-${this.id}`);
        this.outputCodeDiv = document.getElementById(`qpyodide-output-code-area-${this.id}`);
        this.outputGraphDiv = document.getElementById(`qpyodide-output-graph-area-${this.id}`);
        
        // Store reference to the object
        var thiz = this;

        // Load the Monaco Editor and create an instance
        require(['vs/editor/editor.main'], function () {
            thiz.editor = monaco.editor.create(
                thiz.editorDiv, {
                    value: thiz.code,
                    language: 'python',
                    theme: 'vs-light',
                    automaticLayout: true,           // Works wonderfully with RevealJS
                    scrollBeyondLastLine: false,
                    minimap: {
                        enabled: false
                    },
                    fontSize: '17.5pt',              // Bootstrap is 1 rem
                    renderLineHighlight: "none",     // Disable current line highlighting
                    hideCursorInOverviewRuler: true,  // Remove cursor indictor in right hand side scroll bar
                    readOnly: thiz.options['read-only'] ?? false
                }
            );
        
            // Store the official counter ID to be used in keyboard shortcuts
            thiz.editor.__qpyodideCounter = thiz.id;
        
            // Store the official div container ID
            thiz.editor.__qpyodideEditorId = `qpyodide-editor-${thiz.id}`;
        
            // Store the initial code value and options
            thiz.editor.__qpyodideinitialCode = thiz.code;
            thiz.editor.__qpyodideOptions = thiz.options;
        
            // Set at the model level the preferred end of line (EOL) character to LF.
            // This prevent `\r\n` from being given to the Pyodide engine if the user is on Windows.
            // See details in: https://github.com/coatless/quarto-Pyodide/issues/94
            // Associated error text: 
            // Error: <text>:1:7 unexpected input
        
            // Retrieve the underlying model
            const model = thiz.editor.getModel();
            // Set EOL for the model
            model.setEOL(monaco.editor.EndOfLineSequence.LF);
        
            // Dynamically modify the height of the editor window if new lines are added.
            let ignoreEvent = false;
            const updateHeight = () => {
            const contentHeight = thiz.editor.getContentHeight();
            // We're avoiding a width change
            //editorDiv.style.width = `${width}px`;
            thiz.editorDiv.style.height = `${contentHeight}px`;
                try {
                    ignoreEvent = true;
            
                    // The key to resizing is this call
                    thiz.editor.layout();
                } finally {
                    ignoreEvent = false;
                }
            };
        
            // Helper function to check if selected text is empty
            function isEmptyCodeText(selectedCodeText) {
                return (selectedCodeText === null || selectedCodeText === undefined || selectedCodeText === "");
            }
        
            // Registry of keyboard shortcuts that should be re-added to each editor window
            // when focus changes.
            const addPyodideKeyboardShortCutCommands = () => {
            // Add a keydown event listener for Shift+Enter to run all code in cell
            thiz.editor.addCommand(monaco.KeyMod.Shift | monaco.KeyCode.Enter, () => {
                // Retrieve all text inside the editor
                thiz.runCode(thiz.editor.getValue());
            });
        
            // Add a keydown event listener for CMD/Ctrl+Enter to run selected code
            thiz.editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
                    // Get the selected text from the editor
                    const selectedText = thiz.editor.getModel().getValueInRange(thiz.editor.getSelection());
                    // Check if no code is selected
                    if (isEmptyCodeText(selectedText)) {
                        // Obtain the current cursor position
                        let currentPosition = thiz.editor.getPosition();
                        // Retrieve the current line content
                        let currentLine = thiz.editor.getModel().getLineContent(currentPosition.lineNumber);
                
                        // Propose a new position to move the cursor to
                        let newPosition = new monaco.Position(currentPosition.lineNumber + 1, 1);
                
                        // Check if the new position is beyond the last line of the editor
                        if (newPosition.lineNumber > thiz.editor.getModel().getLineCount()) {
                            // Add a new line at the end of the editor
                            thiz.editor.executeEdits("addNewLine", [{
                            range: new monaco.Range(newPosition.lineNumber, 1, newPosition.lineNumber, 1),
                            text: "\n", 
                            forceMoveMarkers: true,
                            }]);
                        }
                        
                        // Run the entire line of code.
                        thiz.runCode(currentLine);
                
                        // Move cursor to new position
                        thiz.editor.setPosition(newPosition);
                    } else {
                        // Code to run when Ctrl+Enter is pressed with selected code
                        thiz.runCode(selectedText);
                    }
                });
            }
        
            // Register an on focus event handler for when a code cell is selected to update
            // what keyboard shortcut commands should work.
            // This is a workaround to fix a regression that happened with multiple
            // editor windows since Monaco 0.32.0 
            // https://github.com/microsoft/monaco-editor/issues/2947
            thiz.editor.onDidFocusEditorText(addPyodideKeyboardShortCutCommands);
        
            // Register an on change event for when new code is added to the editor window
            thiz.editor.onDidContentSizeChange(updateHeight);
        
            // Manually re-update height to account for the content we inserted into the call
            updateHeight();
                
        });

        
        // Add a click event listener to the run button
        thiz.runButton.onclick = function () {
            thiz.runCode(
                thiz.editor.getValue()
            );
        };
        
        // Add a click event listener to the reset button
        thiz.copyButton.onclick = function () {
            // Retrieve current code data
            const data = thiz.editor.getValue();
            
            // Write code data onto the clipboard.
            navigator.clipboard.writeText(data || "");
        };
        
        // Add a click event listener to the copy button
        thiz.resetButton.onclick = function () {
            thiz.editor.setValue(thiz.editor.__qpyodideinitialCode);
        };
    }

    disableInteractiveCells() {
        // Enable locking of execution for the cell
        this.executionLock = true;

        // Disallowing execution of other code cells
        document.querySelectorAll(".qpyodide-button-run").forEach((btn) => {
            btn.disabled = true;
        });
    }

    enableInteractiveCells() {
        // Remove locking of execution for the cell
        this.executionLock = false;

        // All execution of other code cells
        document.querySelectorAll(".qpyodide-button-run").forEach((btn) => {
            btn.disabled = false;
        });
    }

    /**
     * Execute the Python code inside the editor.
     */
    async runCode(code) {
        
        // Check if we have an execution lock
        if (this.executeLock) return; 
        
        this.disableInteractiveCells();

        // Force wait procedure
        await mainPyodide;

        // Clear the output stock
        qpyodideResetOutputArray();

        // Generate a new canvas element, avoid attaching until the end
        let graphFigure = document.createElement("figure");
        document.pyodideMplTarget = graphFigure;

        console.log("Running code!");
        // Obtain results from the base class
        try {
            // Always check to see if the user adds new packages
            await mainPyodide.loadPackagesFromImports(code);

            // Process result
            const output = await mainPyodide.runPythonAsync(code);

            // Add output
            qpyodideAddToOutputArray(output, "stdout");
        } catch (err) {
            // Add error message
            qpyodideAddToOutputArray(err, "stderr");
            // TODO: There has to be a way to remove the Pyodide portion of the errors... 
        }

        const result = qpyodideRetrieveOutput();

        // Nullify the output area of content
        this.outputCodeDiv.innerHTML = "";
        this.outputGraphDiv.innerHTML = "";        

        // Design an output object for messages
        const pre = document.createElement("pre");
        if (/\S/.test(result)) {
            // Display results as HTML elements to retain output styling
            const div = document.createElement("div");
            div.innerHTML = result;
            pre.appendChild(div);
        } else {
            // If nothing is present, hide the element.
            pre.style.visibility = "hidden";
        }

        // Add output under interactive div
        this.outputCodeDiv.appendChild(pre);

        // Place the graphics onto the page
        if (graphFigure) {

            if (this.options['fig-cap']) {
                // Create figcaption element
                const figcaptionElement = document.createElement('figcaption');
                figcaptionElement.innerText = this.options['fig-cap'];
                // Append figcaption to figure
                graphFigure.appendChild(figcaptionElement);    
            }

            this.outputGraphDiv.appendChild(graphFigure);
        }

        // Re-enable execution
        this.enableInteractiveCells();
    }
};

/**
 * OutputCell class for customizing and displaying output.
 * @class
 * @extends BaseCell
 */
class OutputCell extends BaseCell {
    /**
     * Constructor for OutputCell.
     * @constructor
     * @param {Object} cellData - JSON object containing code, id, and options.
     */
    constructor(cellData) {
      super(cellData);
    }
  
    /**
     * Display customized output on the page.
     * @param {*} output - Result to be displayed.
     */
    displayOutput(output) {
        const results = this.executeCode();
        return results;
    }
  }

/**
 * SetupCell class for suppressed output.
 * @class
 * @extends BaseCell
 */
class SetupCell extends BaseCell {
    /**
     * Constructor for SetupCell.
     * @constructor
     * @param {Object} cellData - JSON object containing code, id, and options.
     */
    constructor(cellData) {
        super(cellData);
    }

    /**
     * Execute the Python code without displaying the results.
     */
    runSetupCode() {
        // Execute code without displaying output
        this.executeCode();
    }
};
</script>
<script type="module">
// Handle cell initialization initialization
qpyodideCellDetails.map(
    (entry) => {
      // Handle the creation of the element
      qpyodideCreateCell(entry);
    }
  );
</script>




</body></html>